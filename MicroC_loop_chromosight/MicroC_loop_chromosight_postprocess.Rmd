---
title: "R Notebook"
---
# LOADING REQUIREMENTS
## PACKAGES
```{r message=FALSE, warning=FALSE, include=FALSE}
# LIST OF PACKAGES
pkgs = c("tidyverse", "here", "svglite", "ggplot2", "ggrepel",
         "stringr", "BiocManager", "RColorBrewer", "viridis", "magick",
         "nlme", "factoextra", "devtools", "beepr", "remotes",
         "cowplot", "data.table", "strawr", "rtracklayer", "utils",
         "reshape2", "VennDiagram","gridExtra", "eulerr", "scales",
         "InteractionSet", "gplots", "locfdr", "future", "ggbeeswarm", "glossary", "ggalluvial", "UpSetR")
bio_pkgs = c("biomaRt", "DESeq2", "ComplexHeatmap", "apeglm", "vsn",
             "rhdf5", "InteractionSet", "plotgardener", "HiCDCPlus",
             "GenomicInteractions", "LOLA", "AnnotationHub",
             "org.Mm.eg.db", "enrichplot", "DOSE", "clusterProfiler",
             "HiCExperiment", "HiCool", "HiContacts", "HiContactsData", "fourDNData", "DNAZooData",
             "MotifDb", "Biostrings")

# INSTALL PACKAGES
# install.packages(pkgs)
# BiocManager::install(bio_pkgs)

# INSTALL HiC related packages
# remotes::install_github("robinweide/GENOVA")
# devtools::install_github("thomasp85/scico")
# devtools::install_github("psyteachr/introdataviz")

# LOAD PACKAGES
lapply(pkgs, require, character.only = TRUE)
lapply(bio_pkgs, require, character.only = TRUE)
require(GENOVA)
require(scico)
require(introdataviz)
require(igraph)
# CLEANING
rm(pkgs, bio_pkgs)

options(scipen=999)



```
## ENSEMBL
```{r}
# ENSEMBL DATABASE
# v102 is for the latest mm10 version
# ensembl.v102 <- useMart(host = "https://nov2020.archive.ensembl.org",
#                        biomart = "ENSEMBL_MART_ENSEMBL",
#                        dataset = "mmusculus_gene_ensembl")
```
## COLOR PALETTE
```{r}
palette_1 = list(red = "#E9002D",
                 amber = "#FFAA00",
                 green = "#00B000")
palette_2 = list(red = "#FF1F5B",
                 green = "#00CD6C",
                 blue = "#009ADE",
                 purple = "#AF58BA",
                 yellow = "#FFC61E",
                 orange = "#F28522",
                 grey = "#A0B1BA",
                 brown = "#A6761D")
palette_3 = list(grey1 = "#a0b1ba",
                 grey2 = "#c5d0d5",
                 grey3 = "#eceff1")

colorListLoop <-  c(palette_3[["grey3"]], palette_3[["grey2"]], palette_3[["grey1"]],
                     "#C5E1EF", "#6CB0D6", "#226E9C",
                     "#06592A", 
                     "#FED976", "#FD8D3C", "#E31A1C")
colorListPromoter <- c(palette_3[["grey3"]],"#E88587", "#E31A1C")
colorListEnhancer <- c(palette_3[["grey3"]],"#87AFC7", "#226E9C")
colorListStructure <- c(palette_3[["grey3"]], palette_3[["grey2"]], palette_3[["grey1"]])
```

## DIR LIST
```{r}
loopDir <- "/Volumes/UKJIN_SSD/data/loop_chromosight"
figDir <- "/Volumes/UKJIN_SSD/figure/loop_chromosight"

dir.create(figDir, showWarnings = FALSE)
```

## FIGURE PARAMETERS
```{r}
library(colorspace)

fontType <- "Helvetica"

fontSizeL <- 10 # pt
fontSizeM <- 8
fontSizeS <- 6

lineThick <- 0.75 # pt
lineMedium <- 0.5
lineThin <- 0.25

panelUnit <- 30 # mm
panelMargin <- 1.5

mmToInch <- 0.03937007874
mmToLineUnit <- 1/2.13
mmToLinePlotgarden <- 1/0.75
ptToMM <- 1/2.845


strong_red <- "#CB333A"
strong_blue <- "#4851A0"
weak_red <- lighten(strong_red, amount = 0.4)   # FF7D81
weak_blue <- lighten(strong_blue, amount = 0.4) # 8A91DD
no_grey <- "#A8A8A8"

strong_teel <- "#0892A5"
strong_green <- "#23CE6B" # A485
strong_darkgreen <- "#054A29"
strong_yellow <- "#FFBA49"
strong_orange <- "#F18F01" # dTAG
strong_lightpurple <- "#BD93D8"
strong_purple <- "#9E33CB" # Epi

panelSize <- function(num, unit = panelUnit, margin = panelMargin){
  return(num*unit - 2*margin)
}

```

## FUNCTIONS
```{r}
importBedpe = function(bedpe){
  a1 = makeGRangesFromDataFrame(data.frame(
    chr = bedpe$V1,
    start = bedpe$V2 +1,
    end = bedpe$V3))
  a2 = makeGRangesFromDataFrame(data.frame(
    chr = bedpe$V4,
    start = bedpe$V5 +1,
    end = bedpe$V6))
  GInteractions(a1, a2)
}

get_density <- function(x, y, ...) {
  dens <- MASS::kde2d(x, y, ...)
  ix <- findInterval(x, dens$x)
  iy <- findInterval(y, dens$y)
  ii <- cbind(ix, iy)
  return(dens$z[ii])
}
label_kb_mb <- function(x) {
  ifelse(x >= 1000000, paste0(x / 1000000, "Mb"), paste0(x / 1000, "kb"))
}

importPeak = function(fileName){
  df = fread(fileName)
  gr = makeGRangesFromDataFrame(data.frame(
    chr = df$V1, start = df$V2, end = df$V3
  ))
}
```


# [v] Make filtered bedpe
```{r}
# Importing & filtering loops
filterLoopBedpe = function(sample, note, cutoff.score, cutoff.qvalue,
                           inputDir, outputDir){
  temp = as_tibble(fread(here(inputDir, 
                              paste0(sample, "_chromosight_", note, ".tsv"))))
  temp.filtered = temp %>% dplyr::filter(score > cutoff.score, qvalue < cutoff.qvalue)
  fwrite(temp.filtered, here(outputDir, paste0(sample, "_chromosight_", note, ".bedpe")), 
         col.names = FALSE,row.names = FALSE, sep = "\t")  
}

#for(sample in c("G1DMSO_pooled", "G1dTAG_pooled", "G1A485_pooled")){
for(sample in c("EpiG1DMSO_pooled", "EpiG1dTAG_pooled")){

  for(note in c("25000bp", "10000bp", "5000bp")){
    filterLoopBedpe(sample = sample, note = note,
                    cutoff.score = 0.3, cutoff.qvalue = 1e-5,
                    inputDir = loopDir, outputDir = loopDir)
  }
}
```

# [v] Evaluating cutoff for pearson correlation of chromosight
```{r}
#for(sample in c("G1DMSO_pooled", "G1dTAG_pooled", "G1A485_pooled")){
for(sample in c("EpiG1DMSO_pooled", "EpiG1dTAG_pooled")){

  for(note in c("25000bp", "10000bp", "5000bp")){
    temp <- as_tibble(fread(here(loopDir, 
                                 paste0(sample, "_chromosight_", note, ".tsv"))))
    for(cutoff in c(0.3, 0.4, 0.5, 0.6, 0.7)){
      if(cutoff == 0.7){
        temp.filtered = temp %>% dplyr::filter(score > cutoff)
        
      }else{
        temp.filtered = temp %>% dplyr::filter(score > cutoff) %>% dplyr::filter(score <= cutoff + 0.1)
        
      }
      fwrite(temp.filtered, here(loopDir, paste0(sample, "_chromosight_", note, "_score", cutoff, ".bedpe")), 
             col.names = FALSE,row.names = FALSE, sep = "\t")  
    }
  }}
```

Making merged figures of APA
```{r}
library(magick)

#----------------------------------------
# Helper: merge all score-cutoff SVGs side-by-side
merge_scores <- function(cond, res, fig_dir, scores,
                         dpi = 600, scale = 2) {
  # build file names
  svg_files <- file.path(
    fig_dir,
    sprintf("APA_%s_pooled_chromosight_%s_score%s.svg",
            cond, res, scores)
  )
  
  # read each SVG at target DPI
  imgs <- lapply(svg_files, function(f) {
    if (file.exists(f)) {
      image_read(f, density = dpi)
    } else {
      warning("Missing SVG: ", f)
      image_blank(1, 1, color = "white")
    }
  })
  
  # append side-by-side
  merged <- image_append(image_join(imgs), stack = FALSE)
  
  # upscale pixels if requested
  if (scale != 1) {
    merged <- image_scale(merged, paste0(scale * 100, "%"))
  }
  
  # write PNG at 600 ppi
  out_png <- file.path(fig_dir, sprintf("%s_%s_merged.png", cond, res))
  image_write(merged, path = out_png, format = "png", density = dpi)
  message("Saved: ", out_png)
}

#----------------------------------------
# Helper: take the three *_merged.png and stack top-to-bottom
stack_resolutions <- function(cond, fig_dir, res_labels,
                              dpi = 600, scale = 2) {
  png_files <- file.path(
    fig_dir,
    sprintf("%s_%s_merged.png", cond, res_labels)
  )
  
  # pick a sample to get dimensions
  good <- png_files[file.exists(png_files)]
  if (length(good) == 0) {
    warning("No merged PNGs found for ", cond)
    return()
  }
  sample_info <- image_info(image_read(good[1]))
  
  # read or blank at that size
  imgs <- lapply(png_files, function(f) {
    if (file.exists(f)) {
      image_read(f)
    } else {
      image_blank(sample_info$width, sample_info$height, color = "white")
    }
  })
  
  # append vertically
  stacked <- image_append(image_join(imgs), stack = TRUE)
  
  # upscale pixels if requested
  if (scale != 1) {
    stacked <- image_scale(stacked, paste0(scale * 100, "%"))
  }
  
  # write final all-res PNG
  out_all <- file.path(fig_dir, sprintf("%s_allResolutions_merged.png", cond))
  image_write(stacked, path = out_all, format = "png", density = dpi)
  message("Saved: ", out_all)
}

#----------------------------------------
# Parameters (tweak scale if you need even bigger)
figDir     <- "/Volumes/UKJIN_SSD/figure/loop_chromosight"
conditions <- c("EpiG1DMSO", "EpiG1dTAG")
res_labels <- c("5000bp", "10000bp", "25000bp")
scores     <- seq(0.3, 0.7, by = 0.1)
dpi        <- 600     # rasterization resolution
scale      <- 2       # 2× pixel dimensions (try 3 or 4 if needed)

#----------------------------------------
# Run everything
for (cond in conditions) {
  for (res in res_labels) {
    merge_scores(cond, res, figDir, scores, dpi, scale)
  }
  stack_resolutions(cond, figDir, res_labels, dpi, scale)
}
```

# Post-processing called loops
Step 2) Post-processing: Synchronizing loops across conditions. 3x3 bin window used to determine whether the loops are same. 
Step 3) Post-processing: Merging over resolutions.
Merge 25kb to lower resolution by checking 25kb 3x3 bin window. If there are 25kb loop that has lower resolution loop within 3x3 window, discard the 25kb called loop. After that, repeat for 10 kb.
## Step 2
```{r}
################################################################################
# Step 2
################################################################################
# Merge loops across condition
for (res in c(25000, 10000, 5000)){
  
  loop1 <- fread(here(loopDir, paste0("G1DMSO_pooled_chromosight_", res, "bp.tsv"))) %>% dplyr::select(seq(1, 6))
  loop2 <- fread(here(loopDir, paste0("G1dTAG_pooled_chromosight_", res, "bp.tsv"))) %>% dplyr::select(seq(1, 6))
  loop3 <- fread(here(loopDir, paste0("G1A485_pooled_chromosight_", res, "bp.tsv"))) %>% dplyr::select(seq(1, 6))
  loop4 <- fread(here(loopDir, paste0("EpiG1DMSO_pooled_chromosight_", res, "bp.tsv"))) %>% dplyr::select(seq(1, 6))
  loop5 <- fread(here(loopDir, paste0("EpiG1dTAG_pooled_chromosight_", res, "bp.tsv"))) %>% dplyr::select(seq(1, 6))

  
  loop.merged <- bind_rows(loop1, loop2, loop3, loop4, loop5) %>% distinct() %>% dplyr::filter(start2 - start1 <= 2e6)
  fwrite(loop.merged, here(loopDir, paste0("chromo_cons_", res, "bp.bedpe")), 
         sep = '\t', col.names = FALSE, row.names = FALSE)
}

# Run "chromosight quantify" with union loops in all condition

# Merge loops across conditions for each resolution. 3x3 bin window used to determine whether the loops are same. 
for (res in c(25000, 10000, 5000)){
  
  score.DMSO.tb <- fread(here(loopDir, paste0("G1DMSO_pooled_cons_", res, "bp_pu100pz100.tsv"))) %>%
    dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_")) %>%
    dplyr::filter(start2 - start1 <= 2e6) %>%
    dplyr::select(c(1, 2, 3, 4, 5, 6, 7, 8, 12, 9, 10, 11)) %>%
    dplyr::rename(score_DMSO = score,
                  pvalue_DMSO = pvalue,
                  qvalue_DMSO = qvalue) 
  score.dTAG.tb <- fread(here(loopDir, paste0("G1dTAG_pooled_cons_", res, "bp_pu100pz100.tsv"))) %>%
    dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_")) %>%
    dplyr::filter(start2 - start1 <= 2e6) %>%
    dplyr::select(c(1, 2, 3, 4, 5, 6, 7, 8, 12, 9, 10, 11)) %>%
    dplyr::rename(score_dTAG = score,
                  pvalue_dTAG = pvalue,
                  qvalue_dTAG = qvalue) 
  score.A485.tb <- fread(here(loopDir, paste0("G1A485_pooled_cons_", res, "bp_pu100pz100.tsv"))) %>%
    dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_")) %>%
    dplyr::filter(start2 - start1 <= 2e6) %>%
    dplyr::select(c(1, 2, 3, 4, 5, 6, 7, 8, 12, 9, 10, 11)) %>%
    dplyr::rename(score_A485 = score,
                  pvalue_A485 = pvalue,
                  qvalue_A485 = qvalue) 
  score.EpiDMSO.tb <- fread(here(loopDir, paste0("EpiG1DMSO_pooled_cons_", res, "bp_pu100pz100.tsv"))) %>%
  dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_")) %>%
  dplyr::filter(start2 - start1 <= 2e6) %>%
  dplyr::select(c(1, 2, 3, 4, 5, 6, 7, 8, 12, 9, 10, 11)) %>%
  dplyr::rename(score_EpiDMSO = score,
                pvalue_EpiDMSO = pvalue,
                qvalue_EpiDMSO = qvalue) 
  score.EpidTAG.tb <- fread(here(loopDir, paste0("EpiG1dTAG_pooled_cons_", res, "bp_pu100pz100.tsv"))) %>%
  dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_")) %>%
  dplyr::filter(start2 - start1 <= 2e6) %>%
  dplyr::select(c(1, 2, 3, 4, 5, 6, 7, 8, 12, 9, 10, 11)) %>%
  dplyr::rename(score_EpidTAG = score,
                pvalue_EpidTAG = pvalue,
                qvalue_EpidTAG = qvalue) 
  
  # Annotate whether the loop was called in DMSO or dTAG condition
  loop.DMSO <- fread(here(loopDir, paste0("G1DMSO_pooled_chromosight_", res, "bp.tsv"))) %>% 
    dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_"))
  loop.dTAG <- fread(here(loopDir, paste0("G1dTAG_pooled_chromosight_", res, "bp.tsv"))) %>% 
    dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_"))
  loop.A485 <- fread(here(loopDir, paste0("G1A485_pooled_chromosight_", res, "bp.tsv"))) %>% 
    dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_"))
  loop.EpiDMSO <- fread(here(loopDir, paste0("EpiG1DMSO_pooled_chromosight_", res, "bp.tsv"))) %>% 
    dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_"))
  loop.EpidTAG <- fread(here(loopDir, paste0("EpiG1dTAG_pooled_chromosight_", res, "bp.tsv"))) %>% 
    dplyr::mutate(id = paste(chrom1, start1, start2, sep = "_"))
  
  score.tb <- full_join(score.DMSO.tb, score.dTAG.tb,
                        by = c("chrom1", "start1", "end1",
                               "chrom2", "start2", "end2",
                               "bin1", "bin2", "id")) %>%
    full_join(score.A485.tb,
              by = c("chrom1", "start1", "end1",
                     "chrom2", "start2", "end2",
                     "bin1", "bin2", "id")) %>%
    full_join(score.EpiDMSO.tb,
                        by = c("chrom1", "start1", "end1",
                               "chrom2", "start2", "end2",
                               "bin1", "bin2", "id")) %>%
    full_join(score.EpidTAG.tb,
                        by = c("chrom1", "start1", "end1",
                               "chrom2", "start2", "end2",
                               "bin1", "bin2", "id")) %>%
    dplyr::mutate(DMSOcalled = id %in% loop.DMSO$id,
                  dTAGcalled = id %in% loop.dTAG$id,
                  A485called = id %in% loop.A485$id,
                  EpiDMSOcalled = id %in% loop.EpiDMSO$id,
                  EpidTAGcalled = id %in% loop.EpidTAG$id) %>%
    dplyr::mutate(
      score = pmax(score_DMSO, score_dTAG, score_A485, score_EpiDMSO, score_EpidTAG),
      .row_id   = row_number()           # temporary ID for graph nodes
    )
  
  # 1) Build neighbor‐edges: all pairs (i, j) with |bin1[i] - bin1[j]| ≤1 AND |bin2[i] - bin2[j]| ≤1
  coords <- score.tb %>% select(bin1, bin2)
  n <- nrow(score.tb)
  
  # 2) Create all (i,j) pairs with i < j, then filter
  pairs <- expand.grid(i = 1:n, j = 1:n) %>%
    filter(i < j) %>%
    filter(
      abs(coords$bin1[i] - coords$bin1[j]) <= 1,
      abs(coords$bin2[i] - coords$bin2[j]) <= 1
    )
  
  # 3) Turn into an undirected graph and extract components
  g <- graph_from_data_frame(pairs, directed = FALSE, vertices = data.frame(name = 1:n))
  comps <- components(g)$membership
  
  # 4) Annotate your tibble with “group” and “is_best”
  score.tb <- score.tb %>%
    mutate(group = comps[.row_id]) %>%
    group_by(group) %>%
    mutate(
      is_best               = score == max(score),
      DMSOcalledProcessed   = any(DMSOcalled),
      dTAGcalledProcessed   = any(dTAGcalled),
      A485calledProcessed   = any(A485called),
      EpiDMSOcalledProcessed = any(EpiDMSOcalled),
      EpidTAGcalledProcessed = any(EpidTAGcalled)
    ) %>%
    ungroup() %>%
    dplyr::select(-.row_id)
  
  temp <- score.tb %>% dplyr::filter(is_best)
  
  
  
  ##############################################################################
  set_colors <- c(
  DMSO      = "#1f77b4",
  dTAG      = "#ff7f0e",
  A485      = "#2ca02c",
  EpiDMSO   = "#d62728",
  EpidTAG   = "#9467bd"
)
  raw_sets <- list(
    DMSO    = which(score.tb$DMSOcalled),
    dTAG    = which(score.tb$dTAGcalled),
    A485    = which(score.tb$A485called),
    EpiDMSO = which(score.tb$EpiDMSOcalled),
    EpidTAG = which(score.tb$EpidTAGcalled)
  )

  svglite(here(figDir, paste0("upset_fullset_raw_", res, ".svg")), width = 6, height = 4)
  print(upset(
    fromList(raw_sets),
    nsets = 5,
    order.by = "freq",
    mb.ratio = c(0.6, 0.4),
    point.size = 3,
    line.size = 1,
    main.bar.color = "steelblue",
    matrix.color = "firebrick"
  ))
  dev.off()
  
  
  # 2) PROCESSED calls
  proc_sets <- list(
    DMSO    = which(temp$DMSOcalledProcessed),
    dTAG    = which(temp$dTAGcalledProcessed),
    A485    = which(temp$A485calledProcessed),
    EpiDMSO = which(temp$EpiDMSOcalledProcessed),
    EpidTAG = which(temp$EpidTAGcalledProcessed)
  )
  
  svglite(here(figDir, paste0("upset_fullset_processed_", res, ".svg")), width = 6, height = 4)
  print(upset(
    fromList(proc_sets),
    nsets = 5,
    order.by = "freq",
    mb.ratio = c(0.6, 0.4),
    point.size = 3,
    line.size = 1,
    main.bar.color = "steelblue",
    matrix.color = "firebrick"
  ))
  dev.off()
  
  
  
  # Export bedpe
  temp <- score.tb %>% dplyr::filter(is_best) %>% dplyr::select(seq(1, 6))
  fwrite(temp, here(loopDir, paste0("chromo_cons_", res, "bp_fullset_postprocessed.bedpe")), sep = "\t", col.names = FALSE)
  
  out.tb <- score.tb %>% dplyr::filter(is_best) %>% dplyr::select(-group, -is_best, -DMSOcalled, -dTAGcalled, -A485called)
  fwrite(out.tb, here(loopDir, paste0("chromo_cons_", res, "bp_fullset_postprocessed.tsv")), sep = "\t")
}


```

## Step 3
```{r}
score.tb.25kb <- fread(here(loopDir, "chromo_cons_25000bp_postprocessed.tsv")) %>% dplyr::mutate(res = 25)
score.tb.10kb <- fread(here(loopDir, "chromo_cons_10000bp_postprocessed.tsv")) %>% dplyr::mutate(res = 10)
score.tb.5kb <- fread(here(loopDir, "chromo_cons_5000bp_postprocessed.tsv")) %>% dplyr::mutate(res = 5)

score.tb <- bind_rows(score.tb.25kb, score.tb.10kb, score.tb.5kb) %>% dplyr::select(-bin1, -bin2)



################

# Convert to data.table
score.tb <- as.data.table(score.tb)


#### Round 1
# Split into reference and comparison sets
loops_25 <- score.tb[res == 25][, .(id, chrom1, start1, chrom2, start2)]
loops_small <- score.tb[res %in% c(5, 10)][, .(id, chrom1, start1, chrom2, start2)]

# Bin resolution in basepairs (same for all since we're using Chebyshev distance of 1 in 25kb)
bin_size <- 25000

# Compute bin coordinates
loops_25[, `:=`(bin1 = start1 %/% bin_size, bin2 = start2 %/% bin_size)]
loops_small[, `:=`(bin1 = start1 %/% bin_size, bin2 = start2 %/% bin_size)]

# Set keys for fast join
setkey(loops_small, chrom1, chrom2, bin1, bin2)

# Initialize a flag column
score.tb[, has_fine_neighbor25 := FALSE]

# Loop over each 25kb loop and check for nearby smaller-res loops
for (i in seq_len(nrow(loops_25))) {
  loop <- loops_25[i]
  nearby <- loops_small[
    chrom1 == loop$chrom1 & chrom2 == loop$chrom2 &
    abs(bin1 - loop$bin1) <= 1 &
    abs(bin2 - loop$bin2) <= 1
  ]
  if (nrow(nearby) > 0) {
    score.tb[res == 25 & id == loop$id, has_fine_neighbor25 := TRUE]
  }
}

#### Round 2
# Split into reference and comparison sets
loops_10 <- score.tb[res == 10][, .(id, chrom1, start1, chrom2, start2)]
loops_small <- score.tb[res %in% c(5)][, .(id, chrom1, start1, chrom2, start2)]

# Bin resolution in basepairs (same for all since we're using Chebyshev distance of 1 in 25kb)
bin_size <- 10000

# Compute bin coordinates
loops_10[, `:=`(bin1 = start1 %/% bin_size, bin2 = start2 %/% bin_size)]
loops_small[, `:=`(bin1 = start1 %/% bin_size, bin2 = start2 %/% bin_size)]

# Set keys for fast join
setkey(loops_small, chrom1, chrom2, bin1, bin2)

# Initialize a flag column
score.tb[, has_fine_neighbor10 := FALSE]

# Loop over each 25kb loop and check for nearby smaller-res loops
for (i in seq_len(nrow(loops_10))) {
  loop <- loops_10[i]
  nearby <- loops_small[
    chrom1 == loop$chrom1 & chrom2 == loop$chrom2 &
    abs(bin1 - loop$bin1) <= 1 &
    abs(bin2 - loop$bin2) <= 1
  ]
  if (nrow(nearby) > 0) {
    score.tb[res == 10 & id == loop$id, has_fine_neighbor10 := TRUE]
  }
}


####### Final loops
score.final.tb <- score.tb %>% dplyr::filter(has_fine_neighbor25==FALSE) %>% dplyr::filter(has_fine_neighbor10==FALSE)
fwrite(score.final.tb, here(loopDir, paste0("chromo_cons_allRes_postprocessed.tsv")), sep = "\t")
fwrite(score.tb, here(loopDir, paste0("chromo_cons_allRes_beforePostprocessed.tsv")), sep = "\t")



fwrite(score.final.tb %>% dplyr::select(seq(1, 6)), here(loopDir, paste0("chromo_cons_allRes_postprocessed.bedpe")), sep = "\t",
       col.names = FALSE)

fwrite(score.final.tb %>% dplyr::filter(DMSOcalledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_postprocessed_DMSO.bedpe")), sep = "\t",
       col.names = FALSE)
fwrite(score.final.tb %>% dplyr::filter(dTAGcalledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_postprocessed_dTAG.bedpe")), sep = "\t",
       col.names = FALSE)
fwrite(score.final.tb %>% dplyr::filter(A485calledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_postprocessed_A485.bedpe")), sep = "\t",
       col.names = FALSE)


fwrite(score.final.tb %>% dplyr::filter(dTAGcalledProcessed) %>% 
         dplyr::filter(!DMSOcalledProcessed) %>% dplyr::filter(!A485calledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_postprocessed_dTAG_specific.bedpe")), sep = "\t",
       col.names = FALSE)

fwrite(score.final.tb %>% dplyr::filter(DMSOcalledProcessed) %>% 
         dplyr::filter(!dTAGcalledProcessed) %>% dplyr::filter(!A485calledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_postprocessed_DMSO_specific.bedpe")), sep = "\t",
       col.names = FALSE)

fwrite(score.final.tb %>% dplyr::filter(A485calledProcessed) %>% 
         dplyr::filter(!DMSOcalledProcessed) %>% dplyr::filter(!dTAGcalledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_postprocessed_A485_specific.bedpe")), sep = "\t",
       col.names = FALSE)

dms_vec   <- score.final.tb$DMSOcalledProcessed
dtag_vec  <- score.final.tb$dTAGcalledProcessed
a485_vec  <- score.final.tb$A485calledProcessed

only_dms    <- sum(dms_vec   & !dtag_vec & !a485_vec)
only_dtag   <- sum(!dms_vec  & dtag_vec & !a485_vec)
only_a485   <- sum(!dms_vec  & !dtag_vec & a485_vec)

dm_dtag     <- sum(dms_vec   & dtag_vec  & !a485_vec)   # DMSO & dTAG only
dm_a485     <- sum(dms_vec   & !dtag_vec & a485_vec)   # DMSO & A485 only
dtag_a485   <- sum(!dms_vec  & dtag_vec & a485_vec)    # dTAG & A485 only

all_three   <- sum(dms_vec   & dtag_vec  & a485_vec)    # DMSO & dTAG & A485

counts <- c(
  DMSO             = only_dms,
  dTAG             = only_dtag,
  A485             = only_a485,
  "DMSO&dTAG"      = dm_dtag,
  "DMSO&A485"      = dm_a485,
  "dTAG&A485"      = dtag_a485,
  "DMSO&dTAG&A485" = all_three
)

fit <- euler(counts)


# render & save
svglite(here(figDir, paste0("euler_DMSO_dTAG_A485_processed_allRes.svg")), width = 4, height = 4)
print(plot(
  fit,
  fills      = list(fill = c("#1f77b4", "#ff7f0e", "#2ca02c"), alpha = 0.5),
  edges      = FALSE,
  labels     = list(fontsize = 16),
  quantities = list(type = "counts", fontface = "bold", fontsize = 14),
  main       = paste0("Overlap: allRes, postprocessed")
))
dev.off()



```


## Step 3 (EpiLC expanded)
```{r}
score.tb.25kb <- fread(here(loopDir, "chromo_cons_25000bp_fullset_postprocessed.tsv")) %>% dplyr::mutate(res = 25)
score.tb.10kb <- fread(here(loopDir, "chromo_cons_10000bp_fullset_postprocessed.tsv")) %>% dplyr::mutate(res = 10)
score.tb.5kb <- fread(here(loopDir, "chromo_cons_5000bp_fullset_postprocessed.tsv")) %>% dplyr::mutate(res = 5)

score.tb <- bind_rows(score.tb.25kb, score.tb.10kb, score.tb.5kb) %>% dplyr::select(-bin1, -bin2)



################

# Convert to data.table
score.tb <- as.data.table(score.tb)


#### Round 1
# Split into reference and comparison sets
loops_25 <- score.tb[res == 25][, .(id, chrom1, start1, chrom2, start2)]
loops_small <- score.tb[res %in% c(5, 10)][, .(id, chrom1, start1, chrom2, start2)]

# Bin resolution in basepairs (same for all since we're using Chebyshev distance of 1 in 25kb)
bin_size <- 25000

# Compute bin coordinates
loops_25[, `:=`(bin1 = start1 %/% bin_size, bin2 = start2 %/% bin_size)]
loops_small[, `:=`(bin1 = start1 %/% bin_size, bin2 = start2 %/% bin_size)]

# Set keys for fast join
setkey(loops_small, chrom1, chrom2, bin1, bin2)

# Initialize a flag column
score.tb[, has_fine_neighbor25 := FALSE]

# Loop over each 25kb loop and check for nearby smaller-res loops
for (i in seq_len(nrow(loops_25))) {
  loop <- loops_25[i]
  nearby <- loops_small[
    chrom1 == loop$chrom1 & chrom2 == loop$chrom2 &
    abs(bin1 - loop$bin1) <= 1 &
    abs(bin2 - loop$bin2) <= 1
  ]
  if (nrow(nearby) > 0) {
    score.tb[res == 25 & id == loop$id, has_fine_neighbor25 := TRUE]
  }
}

#### Round 2
# Split into reference and comparison sets
loops_10 <- score.tb[res == 10][, .(id, chrom1, start1, chrom2, start2)]
loops_small <- score.tb[res %in% c(5)][, .(id, chrom1, start1, chrom2, start2)]

# Bin resolution in basepairs (same for all since we're using Chebyshev distance of 1 in 25kb)
bin_size <- 10000

# Compute bin coordinates
loops_10[, `:=`(bin1 = start1 %/% bin_size, bin2 = start2 %/% bin_size)]
loops_small[, `:=`(bin1 = start1 %/% bin_size, bin2 = start2 %/% bin_size)]

# Set keys for fast join
setkey(loops_small, chrom1, chrom2, bin1, bin2)

# Initialize a flag column
score.tb[, has_fine_neighbor10 := FALSE]

# Loop over each 25kb loop and check for nearby smaller-res loops
for (i in seq_len(nrow(loops_10))) {
  loop <- loops_10[i]
  nearby <- loops_small[
    chrom1 == loop$chrom1 & chrom2 == loop$chrom2 &
    abs(bin1 - loop$bin1) <= 1 &
    abs(bin2 - loop$bin2) <= 1
  ]
  if (nrow(nearby) > 0) {
    score.tb[res == 10 & id == loop$id, has_fine_neighbor10 := TRUE]
  }
}


####### Final loops
score.final.tb <- score.tb %>% dplyr::filter(has_fine_neighbor25==FALSE) %>% dplyr::filter(has_fine_neighbor10==FALSE)
fwrite(score.final.tb, here(loopDir, paste0("chromo_cons_allRes_fullset_postprocessed.tsv")), sep = "\t")
fwrite(score.tb, here(loopDir, paste0("chromo_cons_allRes_fullset_beforePostprocessed.tsv")), sep = "\t")



fwrite(score.final.tb %>% dplyr::select(seq(1, 6)), here(loopDir, paste0("chromo_cons_allRes_fullset_postprocessed.bedpe")), sep = "\t",
       col.names = FALSE)

fwrite(score.final.tb %>% dplyr::filter(DMSOcalledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_fullset_postprocessed_DMSO.bedpe")), sep = "\t",
       col.names = FALSE)
fwrite(score.final.tb %>% dplyr::filter(dTAGcalledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_fullset_postprocessed_dTAG.bedpe")), sep = "\t",
       col.names = FALSE)
fwrite(score.final.tb %>% dplyr::filter(A485calledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_fullset_postprocessed_A485.bedpe")), sep = "\t",
       col.names = FALSE)
fwrite(score.final.tb %>% dplyr::filter(EpiDMSOcalledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_fullset_postprocessed_EpiDMSO.bedpe")), sep = "\t",
       col.names = FALSE)
fwrite(score.final.tb %>% dplyr::filter(EpidTAGcalledProcessed) %>% dplyr::select(seq(1, 6)), 
       here(loopDir, paste0("chromo_cons_allRes_fullset_postprocessed_EpidTAG.bedpe")), sep = "\t",
       col.names = FALSE)

# Upset plot

proc_sets <- list(
    DMSO    = which(score.tb$DMSOcalledProcessed),
    dTAG    = which(score.tb$dTAGcalledProcessed),
    A485    = which(score.tb$A485calledProcessed),
    EpiDMSO = which(score.tb$EpiDMSOcalledProcessed),
    EpidTAG = which(score.tb$EpidTAGcalledProcessed)
  )
  
  svglite(here(figDir, paste0("upset_fullset_processedHalf_allRes.svg")), width = 6, height = 4)
  print(upset(
    fromList(proc_sets),
    nsets = 5,
    order.by = "freq",
    mb.ratio = c(0.6, 0.4),
    point.size = 3,
    line.size = 1,
    main.bar.color = "steelblue",
    matrix.color = "firebrick"
  ))
  dev.off()


proc_sets <- list(
    DMSO    = which(score.final.tb$DMSOcalledProcessed),
    dTAG    = which(score.final.tb$dTAGcalledProcessed),
    A485    = which(score.final.tb$A485calledProcessed),
    EpiDMSO = which(score.final.tb$EpiDMSOcalledProcessed),
    EpidTAG = which(score.final.tb$EpidTAGcalledProcessed)
  )
  
  svglite(here(figDir, paste0("upset_fullset_processed_allRes.svg")), width = 6, height = 4)
  print(upset(
    fromList(proc_sets),
    nsets = 5,
    order.by = "freq",
    mb.ratio = c(0.6, 0.4),
    point.size = 3,
    line.size = 1,
    main.bar.color = "steelblue",
    matrix.color = "firebrick"
  ))
  dev.off()



```

### [revisit] Chromosight vs hiccups
```{r}
# 1) load & rename so both tables have (chr1,start1,end1,chr2,start2,end2)
loop.chromo <- fread(here("result","chromo_cons_allRes_postprocessed_DMSO.bedpe"))[ , 1:6 ]
setnames(loop.chromo,
         old = names(loop.chromo),
         new = c("chr1","start1","end1","chr2","start2","end2"))

loop.hiccup <- fread(here("../hiccups","hiccups_DMSO_merged_loops.bedpe"),
                     skip = 2)[ , 1:6 ]
setnames(loop.hiccup,
         old = names(loop.hiccup),
         new = c("chr1","start1","end1","chr2","start2","end2"))


# give each loop a unique ID
loop.chromo[,   loop_id := .I]
loop.hiccup[, hic_id   := .I]

# 2) define 10 kb bin, compute midpoints, then assign bins
bin_size <- 25000L

for (DT in list(loop.chromo, loop.hiccup)) {
  DT[, mid1 := (start1 + end1) %/% 2]
  DT[, mid2 := (start2 + end2) %/% 2]
  DT[, bin1 := mid1 %/% bin_size]
  DT[, bin2 := mid2 %/% bin_size]
}

# 3) for Chebyshev ≤1, expand hiccup loops into the 3×3 neighborhood of bins
hic_nb <- loop.hiccup[
  , CJ(bin1 = bin1 + -1:1,
       bin2 = bin2 + -1:1),
    by = .(chr1, chr2, hic_id)
]

# 4) key & join
setkey(loop.chromo, chr1, chr2, bin1, bin2)
setkey(hic_nb,       chr1, chr2, bin1, bin2)

overlaps <- loop.chromo[ hic_nb, nomatch = 0L ]

# 5) counts
cat("Chromo loops overlapping HiCCUPS:", uniqueN(overlaps$loop_id), "\n")
cat("HiCCUPS loops overlapping Chromo set:", uniqueN(overlaps$hic_id), "\n")
cat("Total matched pairs:", nrow(overlaps), "\n")


chromo  <- nrow(loop.chromo)
overlap <- mean(uniqueN(overlaps$loop_id), uniqueN(overlaps$hic_id))%/%1
hiccups  <- nrow(loop.hiccup)

# fit Euler with only‐DMSO, only‐dTAG, and overlap
fit <- euler(c(
  chromo        = chromo  - overlap,
  hiccups        = hiccups - overlap,
  "chromo&hiccups" = overlap
))

# render & save
png(paste0("euler_chromo_vs_hiccups_25kb_ChebyshevDist1_DMSO.png"), width = 4, height = 4, units = "in", res = 600)
print(plot(fit,
           fills      = list(fill = c("#1f77b4","#ff7f0e"), alpha = .5),
           edges      = FALSE,
           labels     = list(fontsize = 16),
           quantities = list(type = "counts", fontface = "bold", fontsize = 14),
           main       = paste0("Chromosight vs Hiccups (DMSO)")
))
dev.off()
```

```{r}
# 1) load & rename so both tables have (chr1,start1,end1,chr2,start2,end2)
loop.chromo <- fread(here("result","chromo_cons_allRes_postprocessed_dTAG.bedpe"))[ , 1:6 ]
setnames(loop.chromo,
         old = names(loop.chromo),
         new = c("chr1","start1","end1","chr2","start2","end2"))

loop.hiccup <- fread(here("../hiccups","hiccups_dTAG_merged_loops.bedpe"),
                     skip = 2)[ , 1:6 ]
setnames(loop.hiccup,
         old = names(loop.hiccup),
         new = c("chr1","start1","end1","chr2","start2","end2"))


# give each loop a unique ID
loop.chromo[,   loop_id := .I]
loop.hiccup[, hic_id   := .I]

# 2) define 10 kb bin, compute midpoints, then assign bins
bin_size <- 25000L

for (DT in list(loop.chromo, loop.hiccup)) {
  DT[, mid1 := (start1 + end1) %/% 2]
  DT[, mid2 := (start2 + end2) %/% 2]
  DT[, bin1 := mid1 %/% bin_size]
  DT[, bin2 := mid2 %/% bin_size]
}

# 3) for Chebyshev ≤1, expand hiccup loops into the 3×3 neighborhood of bins
hic_nb <- loop.hiccup[
  , CJ(bin1 = bin1 + -1:1,
       bin2 = bin2 + -1:1),
    by = .(chr1, chr2, hic_id)
]

# 4) key & join
setkey(loop.chromo, chr1, chr2, bin1, bin2)
setkey(hic_nb,       chr1, chr2, bin1, bin2)

overlaps <- loop.chromo[ hic_nb, nomatch = 0L ]

# 5) counts
cat("Chromo loops overlapping HiCCUPS:", uniqueN(overlaps$loop_id), "\n")
cat("HiCCUPS loops overlapping Chromo set:", uniqueN(overlaps$hic_id), "\n")
cat("Total matched pairs:", nrow(overlaps), "\n")


chromo  <- nrow(loop.chromo)
overlap <- mean(uniqueN(overlaps$loop_id), uniqueN(overlaps$hic_id))%/%1
hiccups  <- nrow(loop.hiccup)

# fit Euler with only‐DMSO, only‐dTAG, and overlap
fit <- euler(c(
  chromo        = chromo  - overlap,
  hiccups        = hiccups - overlap,
  "chromo&hiccups" = overlap
))

# render & save
png(paste0("euler_chromo_vs_hiccups_25kb_ChebyshevDist1_dTAG.png"), width = 4, height = 4, units = "in", res = 600)
print(plot(fit,
           fills      = list(fill = c("#1f77b4","#ff7f0e"), alpha = .5),
           edges      = FALSE,
           labels     = list(fontsize = 16),
           quantities = list(type = "counts", fontface = "bold", fontsize = 14),
           main       = paste0("Chromosight vs Hiccups (dTAG)")
))
dev.off()
```
### [revisit] Compare loop score
```{r}

score.tb <- fread(here(loopDir, "chromo_cons_allRes_postprocessed.tsv"))
### Drawing
score.tb$density <- get_density(score.tb$score_DMSO, score.tb$score_dTAG, n = 100)
score.tb <- score.tb %>% dplyr::arrange(density)
diffCutoff = 0.2
p1 <- ggplot(score.tb, aes(x = score_DMSO, y = score_dTAG, color = density)) +
  geom_point() + 
  scale_color_viridis() +
  xlim(-0.5, 1) + ylim(-0.5, 1) + coord_fixed() +
  geom_abline(slope = 1, intercept = 0, col = "grey50", linetype = "dashed") +
  geom_hline(yintercept = 0, alpha = 0.5, color = "grey") +
  geom_vline(xintercept = 0, alpha = 0.5, color = "grey") +
  geom_abline(slope = 1, intercept = -diffCutoff, col = "red", linetype = "dotted",
      color = "black",
      size = lineThick*mmToLineUnit,
      lineend = "square") +
    geom_abline(slope = 1, intercept = diffCutoff, col = "red", linetype = "dotted",
      color = "black",
      size = lineThick*mmToLineUnit,
      lineend = "square") +
  theme_classic() + ggtitle(paste0("allRes loop scores"))


png(here(figDir, paste0("consensus_score_scatterplot_allRes_pu100pz100.png")), res = 600, units = "in", width = 5*1.5, height = 2.5*1.5)
print(p1)
dev.off()
svglite(here(figDir, paste0("consensus_score_scatterplot_allRes_pu100pz100.svg")), width = 5*1.5, height = 2.5*1.5)
print(p1)
dev.off()

```

# Annotating loop
## Importing peaks
```{r}
refDir <- here("reference")
peak.H3K4me3 <- importPeak(here(refDir, "ChIP","H3K4me3_ESC_unionPeaks.bed"))

# Filtering H3K4me3 peaks near TSS
flankSize <- 2500
gene.tb <- fread(here(refDir, "mm10", "mm10_GRCm38.p6_gene_sorted.bed")) %>%
  dplyr::mutate(TSS = ifelse(V4 == "+", V2, V3),
                TSSstart = TSS - flankSize,
                TSSend = TSS + flankSize) %>%
  dplyr::select(V1, TSSstart, TSSend)
colnames(gene.tb) <- c("chr", "start", "end")
TSSflank.gr <- makeGRangesFromDataFrame(gene.tb)
temp <- peak.H3K4me3[unique(queryHits(findOverlaps(peak.H3K4me3, TSSflank.gr)))]
fwrite(as_tibble(temp), here(refDir, "ChIP",
                             paste0("H3K4me3_ESC_unionPeaks_", 
                                    flankSize/1000, "kbTSS.bed")), sep = "\t", col.names = FALSE)
```

```{r}
#### Importing ChIP-exo peaks
refDir <- here("reference")
peak.H3K27ac <- importPeak(here(refDir, "ChIP", "H3K27ac_ESC_unionPeaks.bed"))
peak.H3K4me3TSS <- importPeak(here(refDir, "ChIP","H3K4me3_ESC_unionPeaks_2.5kbTSS.bed"))
peak.CTCF <- importPeak(here(refDir, "ChIP","CTCF_ESC_unionPeaks.bed"))
peak.RAD21 <- importPeak(here(refDir, "ChIP","RAD21_ESC-DMSO_unionPeaks.bed"))
peak.Whyte.SE <- importPeak(here(refDir, "mm10", "superEnhancer_Whyte_ESC_mm10.bed"))
peak.Dylan.SE <- importPeak(here(refDir, "mm10", "superEnhancer_Dylan_ESC.bed"))
```
#### Functions
```{r}
createLoopAnnotation <- function(bedpe.loop.anno, name, figDir, colorList){
  temp = bedpe.loop.anno %>%
    dplyr::mutate(sample = name)
  
  num = nrow(temp)
  p7 = ggplot(temp, aes(x = sample, fill = Anno2)) +
    geom_bar(color = "black") +
    theme_bw() +
    labs(title = paste0(num, " loops"),
         x = "", y = "Counts") +
    scale_y_continuous(labels = comma_format()) +
    theme(plot.title = element_text(hjust = 0.5),
          aspect.ratio = 5,
          legend.position = "right",
          legend.direction  = "vertical") +
    scale_fill_manual(values = colorList)
  
  width = 3
  height = 5
  svglite(here(figDir,
               paste0("loopClassify_", name, ".svg")),
          width = width, height = height)
  plot(p7)
  invisible(dev.off())
  png(here(figDir,
           paste0("loopClassify_", name, ".png")),
      width = width, height = height, res = 600, units = "in")
  plot(p7)
  invisible(dev.off())
}


annotateLoopRelaxedTSS <- function(bedpe.anno){
  temp = bedpe.anno %>% dplyr::rowwise() %>%
    dplyr::mutate(
      A1 = if_else((A1_H3K4me3TSS), "P", 
                   if_else((A1_H3K27ac), "E",
                           if_else((A1_CTCF|A1_RAD21), "S", "X"))),
      A2 = if_else((A2_H3K4me3TSS), "P", 
                   if_else((A2_H3K27ac), "E",
                           if_else((A2_CTCF|A2_RAD21), "S", "X")))
    )
  temp = temp %>% dplyr::rowwise() %>%
    dplyr::mutate(Anno = paste0(A1, "-", A2),
                  Anno2 = if_else(Anno == "E-P", "P-E", 
                                  if_else(Anno == "S-P", "P-S",
                                          if_else(Anno == "X-P", "P-X",
                                                  if_else(Anno == "S-E", "E-S",
                                                          if_else(Anno == "X-E", "E-X",
                                                                  if_else(Anno == "X-S", "S-X",
                                                                          Anno)))))),
    )
  
  temp$Anno2 = factor(temp$Anno2, level = c("X-X",
                                            "S-X", "S-S",
                                            "E-X","E-S","E-E",
                                            "P-E","P-X", "P-S", "P-P"))
  
  # Checking the precense of super enhancer
  temp <- temp %>% dplyr::rowwise() %>%
    dplyr::mutate(AnnoSE = ifelse(A1_Whyte.SE | A2_Whyte.SE, "SE", "NO"))
  temp$AnnoSE <- factor(temp$AnnoSE, level = c("SE", "NO"))
  
  return(temp)
}

annotateLoopPromoterTSS <- function(bedpe.anno){
  temp = bedpe.anno %>% dplyr::rowwise() %>%
    dplyr::mutate(
      A1 = if_else((A1_H3K4me3TSS), "P", "N"),
      A2 = if_else((A2_H3K4me3TSS), "P", "N")
    )
  temp = temp %>% dplyr::rowwise() %>%
    dplyr::mutate(Anno = paste0(A1, "-", A2),
                  Anno2 = if_else(Anno == "N-P", "P-N", Anno))
  
  temp$Anno2 = factor(temp$Anno2, level = c("N-N", "P-N", "P-P"))
  
  return(temp)
}

annotateLoopEnhancer <- function(bedpe.anno){
  temp = bedpe.anno %>% dplyr::rowwise() %>%
    dplyr::mutate(
      A1 = if_else((A1_H3K27ac), "E", "N"),
      A2 = if_else((A2_H3K27ac), "E", "N")
    )
  temp = temp %>% dplyr::rowwise() %>%
    dplyr::mutate(Anno = paste0(A1, "-", A2),
                  Anno2 = if_else(Anno == "N-E", "E-N", Anno))
  temp$Anno2 = factor(temp$Anno2, level = c("N-N", "E-N", "E-E"))
  
  return(temp)
}

annotateLoopStructure <- function(bedpe.anno){
  temp = bedpe.anno %>% dplyr::rowwise() %>%
    dplyr::mutate(
      A1 = if_else((A1_CTCF|A1_RAD21), "S", "N"),
      A2 = if_else((A2_CTCF|A2_RAD21), "S", "N")
    )
  temp = temp %>% dplyr::rowwise() %>%
    dplyr::mutate(Anno = paste0(A1, "-", A2),
                  Anno2 = if_else(Anno == "N-S", "S-N", Anno))
  temp$Anno2 = factor(temp$Anno2, level = c("N-N", "S-N", "S-S"))
  return(temp)
}


annotateAnchorTSS <- function(bedpe){
  tb.loop = 
    setOverlapColumn("Whyte.SE",
                     setOverlapColumn("CTCF",
                                      setOverlapColumn("RAD21",
                                                       setOverlapColumn("H3K27ac",
                                                                        setOverlapColumn("H3K4me3TSS", bedpe)))))
  return(tb.loop)
}

setOverlapColumn <- function(peakName, loop){
  tb.loop = as_tibble(loop)
  overlap = returnOverlapIndexLixt(get(paste0("peak.", peakName)), tb.loop)
  tb.loop[[paste0("A1_", peakName)]] = FALSE
  tb.loop[[paste0("A1_", peakName)]][overlap[[1]]] = TRUE
  tb.loop[[paste0("A2_", peakName)]] = FALSE
  tb.loop[[paste0("A2_", peakName)]][overlap[[2]]] = TRUE
  return(tb.loop)
}

returnOverlapIndexLixt <- function(peak, loop){
  anchor1.tb = as_tibble(loop) %>% dplyr::select(chrom1, start1, end1)
  anchor1 = makeGRangesFromDataFrame(data.frame(
    chr = anchor1.tb$chrom1,
    start = anchor1.tb$start1,
    end = anchor1.tb$end1
  ))
  
  anchor2.tb = as_tibble(loop) %>% dplyr::select(chrom2, start2, end2)
  anchor2 = makeGRangesFromDataFrame(data.frame(
    chr = anchor2.tb$chrom2,
    start = anchor2.tb$start2,
    end = anchor2.tb$end2
  ))
  
  overlap = list(overlap1 = unique(queryHits(findOverlaps(anchor1, peak))),
                 overlap2 = unique(queryHits(findOverlaps(anchor2, peak))))
  return(overlap)
}

saveAnnoGroupBedpe <- function(temp, anno.list, name, annoName, ouDir){
  loop = temp %>% dplyr::filter(Anno2 %in% anno.list) %>%
    dplyr::select(c("chrom1", "start1", "end1", "chrom2", "start2", "end2"))
  fwrite(loop, here(outDir, paste0(name, "_", annoName, ".bedpe")), sep = "\t", col.names = FALSE)
}

annotateAnchorTSSAnchor <- function(bed){
  tb.anchor = 
    setOverlapColumnAnchor("Whyte.SE",
                     setOverlapColumnAnchor("CTCF",
                                      setOverlapColumnAnchor("RAD21",
                                                       setOverlapColumnAnchor("H3K27ac",
                                                                        setOverlapColumnAnchor("H3K4me3TSS", bed)))))
  return(tb.anchor)
}

setOverlapColumnAnchor <- function(peakName, anchor){
  tb.anchor = as_tibble(anchor)
  overlap = returnOverlapIndexListAnchor(get(paste0("peak.", peakName)), tb.anchor)
  tb.anchor[[paste0("A1_", peakName)]] = FALSE
  tb.anchor[[paste0("A1_", peakName)]][overlap] = TRUE
  return(tb.anchor)
}

returnOverlapIndexListAnchor <- function(peak, anchor){
  anchor1.tb = as_tibble(anchor) %>% dplyr::select(chr, start, end)
  anchor1 = makeGRangesFromDataFrame(data.frame(
    chr = anchor1.tb$chr,
    start = anchor1.tb$start,
    end = anchor1.tb$end
  ))
  
  overlap = unique(queryHits(findOverlaps(anchor1, peak)))
  return(overlap)
}

```

#### Annotation with ChIP
```{r}
consensus.loop.tb <- fread(here(loopDir, "chromo_cons_allRes_postprocessed.tsv"))

################################################################################
# Annotating with strict priority (P-TSS > E > S)
temp.anno.TSS <- annotateAnchorTSS(consensus.loop.tb) %>%
  dplyr::mutate(
    diff_dTAG_DMSO = (score_dTAG - score_DMSO),
    diff_A485_DMSO = (score_A485 - score_DMSO))

name <- "chromo_cons_allRes_postprocessed_annoHierarchy"
consensus.loop.anno.tb <- annotateLoopRelaxedTSS(temp.anno.TSS)
fwrite(consensus.loop.anno.tb, here(loopDir, paste0(name, ".tsv")), 
       sep = "\t", col.names = TRUE)
createLoopAnnotation(consensus.loop.anno.tb, name, figDir, colorListLoop)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, unique(consensus.loop.anno.tb$Anno2) , name, "all", outDir)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("P-P", "P-E", "P-S", "P-X", "E-E", "E-S", "E-X"), name, "regulatory", outDir)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("S-S", "S-X"), name, "structure", outDir)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("X-X"), name, "x-x", outDir)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("P-P", "P-E", "P-S", "P-X"), name, "p-n", outDir)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("P-P", "P-E", "E-E"), name, "pe-pe", outDir)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("P-P", "P-E"), name, "p-pe", outDir)
# 
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("P-P"), name, "p-p", outDir)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("P-E"), name, "p-e", outDir)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("P-S"), name, "p-s", outDir)
# saveAnnoGroupBedpe(consensus.loop.anno.tb, c("P-X"), name, "p-x", outDir)
```
#### Annotation with ChIP (EpiLC expanded)
```{r}
consensus.loop.tb <- fread(here(loopDir, "chromo_cons_allRes_fullset_postprocessed.tsv"))

################################################################################
# Annotating with strict priority (P-TSS > E > S)
temp.anno.TSS <- annotateAnchorTSS(consensus.loop.tb) %>%
  dplyr::mutate(
    diff_dTAG_DMSO = (score_dTAG - score_DMSO),
    diff_A485_DMSO = (score_A485 - score_DMSO))

name <- "chromo_cons_allRes_fullset_postprocessed_annoHierarchy"
consensus.loop.anno.tb <- annotateLoopRelaxedTSS(temp.anno.TSS)
fwrite(consensus.loop.anno.tb, here(loopDir, paste0(name, ".tsv")), 
       sep = "\t", col.names = TRUE)
createLoopAnnotation(consensus.loop.anno.tb, name, figDir, colorListLoop)
```

## Annotation with ChromHMM
### Group ChromHMM
```{r}
# Preprocessing chromhmm annotation
temp <- fread("/Volumes/UKJIN_SSD/MtoG1_analysis_code/reference/chromHMM_fullstack/mm10_100_segments_segments.bed")

filtered <- temp %>%
  # first filter down to only the rows you care about
  mutate(
    V5 = case_when(
      str_detect(V4, regex("mOpenC6|mOpenC7",      ignore_case = TRUE)) ~ "insulator",
      str_detect(V4, regex("mHet",                 ignore_case = TRUE)) ~ "heterochromatin",
      str_detect(V4, regex("mReprPC",              ignore_case = TRUE)) ~ "repressive",
      str_detect(V4, regex("mEnhA|mEnhWk|mTxEnh",  ignore_case = TRUE)) ~ "enhancer",
      str_detect(V4, regex("mBivProm|mPromF|mTSS|mTxEx3",
                           ignore_case = TRUE)) ~ "promoter",
      str_detect(V4, regex("mTx1|mTx2|mTx3|mTx4|mTx5|mTx6|mTx7|mTx8|mTxEx1|mTxEx2|mTxWk1|mTxWk2",          ignore_case = TRUE)) ~ "transcription",
      TRUE       ~ NA_character_
    )
  )

outtemp <- filtered %>% dplyr::select(c(1, 2, 3, 5)) %>% dplyr::filter(!is.na(V5))
fwrite(outtemp, "/Volumes/UKJIN_SSD/MtoG1_analysis_code/reference/chromHMM_fullstack/mm10_100_segments_segments_grouped.bed", sep = "\t", col.names = FALSE)
```

### (WIP) Group ChromHMM + RAD21 peaks
```{r}
# 1) Read your full‐stack segments
segments <- fread(
  "/Volumes/UKJIN_SSD/MtoG1_analysis_code/reference/chromHMM_fullstack/mm10_100_segments_segments.bed",
  col.names = c("chr","start","end","state")
)

# 2) Read the RAD21 peaks
rad21 <- fread(here(refDir, "ChIP","RAD21_ESC-DMSO_unionPeaks.bed"),
  col.names = c("chr","start","end")
)

# 3) Tag every segment with an index so we can mark overlaps
segments[, seg_id := .I]

# 4) Prepare for foverlaps: set keys on chr, start, end
setkey(segments, chr, start, end)
setkey(rad21,    chr, start, end)

# 5) Find all overlaps (type = "any") — nomatch=0L drops non‐overlapping
ov <- foverlaps(segments, rad21, type = "any", nomatch = 0L)

# 6) In the original table, mark any seg_id that showed up in ov as insulator
segments[, V5 := NA_character_]
segments[ seg_id %in% unique(ov$seg_id), V5 := "insulator" ]

# 7) Now do your regex‐based assignment *only* for those still NA
segments <- segments %>%
  mutate(
    V5 = case_when(
      V5 == "insulator"                             ~ "insulator",
      str_detect(state, regex("mOpenC6|mOpenC7",     ignore_case = TRUE)) ~ "insulator",
      str_detect(state, regex("mHet",                ignore_case = TRUE)) ~ "heterochromatin",
      str_detect(state, regex("mReprPC",             ignore_case = TRUE)) ~ "repressive",
      str_detect(state, regex("mEnhA|mEnhWk|mTxEnh", ignore_case = TRUE)) ~ "enhancer",
      str_detect(state, regex("mBivProm|mPromF|mTSS|mTxEx3", ignore_case = TRUE)) ~ "promoter",
      str_detect(state, regex("mTx1|mTx2|mTx3|mTx4|mTx5|mTx6|mTx7|mTx8|mTxEx1|mTxEx2|mTxWk1|mTxWk2", ignore_case = TRUE)) ~ "transcription",
      TRUE                                           ~ NA_character_
    ),
    V6 = case_when(
      str_detect(state, regex("mOpenC6|mOpenC7",     ignore_case = TRUE)) ~ "insulator",
      str_detect(state, regex("mHet",                ignore_case = TRUE)) ~ "heterochromatin",
      str_detect(state, regex("mReprPC",             ignore_case = TRUE)) ~ "repressive",
      str_detect(state, regex("mEnhA|mEnhWk|mTxEnh", ignore_case = TRUE)) ~ "enhancer",
      str_detect(state, regex("mBivProm|mPromF|mTSS|mTxEx3", ignore_case = TRUE)) ~ "promoter",
      str_detect(state, regex("mTx1|mTx2|mTx3|mTx4|mTx5|mTx6|mTx7|mTx8|mTxEx1|mTxEx2|mTxWk1|mTxWk2", ignore_case = TRUE)) ~ "transcription",
      TRUE                                           ~ NA_character_
    )
  )

# temp <- segments %>% dplyr::filter(V5 == "insulator") %>%
#   dplyr::select(V6)
# temp$V1 = "name"
# ggplot(temp, aes(x = V1, fill = V6)) +
#     geom_bar() +
#     theme_bw() +
#     scale_y_continuous(labels = comma_format()) +
#     theme(plot.title = element_text(hjust = 0.5),
#           aspect.ratio = 5,
#           legend.position = "right",
#           legend.direction  = "vertical")
#     

# 8) Select only chr,start,end,V5 and drop any leftover NAs
outtemp <- segments %>%
  select(chr, start, end, V5) %>%
  filter(!is.na(V5))

# 9) Write it out
fwrite(
  outtemp,
  "/Volumes/UKJIN_SSD/MtoG1_analysis_code/reference/chromHMM_fullstack/mm10_100_segments_segments_grouped_ChIP.bed",
  sep = "\t",
  col.names = FALSE
)
```



```{r}
consensus.loop.tb <- fread(here(loopDir, "chromo_cons_allRes_fullset_postprocessed.tsv"))

loop <- as_tibble(consensus.loop.tb)
anchor1.tb <- as_tibble(loop) %>% dplyr::select(chrom1, start1, end1)
colnames(anchor1.tb) <- c("chr", "start", "end")
anchor2.tb <- as_tibble(loop) %>% dplyr::select(chrom2, start2, end2)
colnames(anchor2.tb) <- c("chr", "start", "end")
anchor.tb <- bind_rows(anchor1.tb, anchor2.tb) %>% 
  distinct()

anchor <- makeGRangesFromDataFrame(data.frame(anchor.tb))
temp <- as_tibble(anchor) %>% dplyr::select(c(1, 2, 3))
fwrite(temp, here(loopDir, "chromo_cons_allRes_fullset_postprocessed_anchor.bed"), sep = "\t", col.names = FALSE)

chromHMM <- fread(here(refDir, "chromHMM_fullstack", "mm10_100_segments_segments.bed"))
colnames(chromHMM) <- c("chr", "start", "end", "state")
chromHMM <- chromHMM %>% dplyr::mutate(start = start+1)
chromHMM <- makeGRangesFromDataFrame(data.frame(chromHMM), keep.extra.columns = TRUE)

hits <- findOverlaps(anchor, chromHMM)
ov <- as.data.frame(hits)
collapsed <- ov %>%
  group_by(queryHits) %>%
  summarize(annot = paste(unique(mcols(chromHMM)$state[subjectHits]), collapse=";"))

collapsed2 <- collapsed %>%
  dplyr::mutate(flag_insulator = str_detect(annot, regex("mOpenC6|mOpenC7", ignore_case = TRUE)),
                flag_heterochromatin = str_detect(annot, regex("mHET", ignore_case = TRUE)),
                flag_repressive = str_detect(annot, regex("mReprPC", ignore_case = TRUE)),
                flag_enhancer = str_detect(annot, regex("mEnhA|mEnhWk|mTxEnh", ignore_case = TRUE)),
                flag_promoter = str_detect(annot, regex("mBivProm|mPromF|mTSS|mTxEx3", ignore_case = TRUE)),
                flag_transcription = str_detect(annot, regex("mTx1|mTx2|mTx3|mTx4|mTx5|mTx6|mTx7|mTx8|mTxEx1|mTxEx2|mTxWk1|mTxWk2", ignore_case = TRUE))) %>%
  dplyr::select(-c(annot))
```

##### Priority ver 1 (to be deleted)
```{r}
### Complex annotation
collapsed3 <- collapsed2 %>%
  dplyr::mutate(annotation = if_else(flag_promoter, "P",
                                     if_else(flag_enhancer, "E",
                                             if_else(flag_insulator, "S",
                                                     if_else(flag_transcription, "T", 
                                                             if_else(flag_repressive, "R",
                                                                     if_else(flag_heterochromatin, "H", "X")))))))

temp <- collapsed3 %>% dplyr::mutate(name = "anchors") %>%
  dplyr::select(name, annotation)
temp <- temp %>%
  mutate(
    annotation = fct_relevel(annotation, (c("P", "E", "S", "T", "R", "X")))
  )
num = nrow(temp)
p7 = ggplot(temp, aes(x = name, fill = annotation)) +
  geom_bar(color = "black") +
  theme_bw() +
  labs(title = paste0(num, " anchors"),
       x = "", y = "Counts") +
  scale_y_continuous(labels = comma_format()) +
  theme(plot.title = element_text(hjust = 0.5),
        aspect.ratio = 5,
        legend.position = "right",
        legend.direction  = "vertical")

### Simple annotation
collapsed3 <- collapsed2 %>%
  dplyr::mutate(annotation = if_else(flag_promoter, "P",
                                     if_else(flag_enhancer, "E",
                                             if_else(flag_insulator, "S", "X"))))

temp <- collapsed3 %>% dplyr::mutate(name = "anchors") %>%
  dplyr::select(name, annotation)
temp <- temp %>%
  mutate(
    annotation = fct_relevel(annotation, (c("P", "E", "S", "X")))
  )
num = nrow(temp)
p7 = ggplot(temp, aes(x = name, fill = annotation)) +
  geom_bar(color = "black") +
  theme_bw() +
  labs(title = paste0(num, " anchors"),
       x = "", y = "Counts") +
  scale_y_continuous(labels = comma_format()) +
  theme(plot.title = element_text(hjust = 0.5),
        aspect.ratio = 5,
        legend.position = "right",
        legend.direction  = "vertical")


anchor.tb$annot_chromHmm <- collapsed3$annotation

annotation.tb <- annotateAnchorTSSAnchor(anchor.tb)  %>% dplyr::rowwise() %>%
    dplyr::mutate(
      annot_chip = if_else((A1_H3K4me3TSS), "P", 
                   if_else((A1_H3K27ac), "E",
                           if_else((A1_CTCF|A1_RAD21), "S", "X")))
    ) %>%
  dplyr::select(annot_chromHmm, annot_chip) %>% ungroup()
  

temp <- annotation.tb %>% dplyr::mutate(name = "anchors") %>%
  dplyr::select(name, annot_chip)
temp <- temp %>%
  mutate(
    annot_chip = fct_relevel(annot_chip, (c("P", "E", "S", "X")))
  )
num = nrow(temp)
p7 = ggplot(temp, aes(x = name, fill = annot_chip)) +
  geom_bar(color = "black") +
  theme_bw() +
  labs(title = paste0(num, " anchors"),
       x = "", y = "Counts") +
  scale_y_continuous(labels = comma_format()) +
  theme(plot.title = element_text(hjust = 0.5),
        aspect.ratio = 5,
        legend.position = "right",
        legend.direction  = "vertical")

library(ggalluvial)

counts <- annotation.tb %>%
  group_by(annot_chromHmm, annot_chip) %>%
  summarise(Freq = n(), .groups = "drop")

counts$annot_chromHmm <- factor(counts$annot_chromHmm, levels = c("P", "E", "S", "X"))
counts$annot_chip <- factor(counts$annot_chip, levels = c("P", "E", "S", "X"))

# 2. Draw the alluvial plot
ggplot(counts,
       aes(axis1 = annot_chromHmm, axis2 = annot_chip, y = Freq)) +
  # flows
  geom_alluvium(aes(fill = annot_chromHmm), width = 0.25) +
  # strata (the blocks at each axis)
  geom_stratum(width = 0.25, fill = "grey80", color = "black") +
  # stratum labels
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3) +
  # axis labels
  scale_x_discrete(limits = c("annot_chromHmm", "annot_chip"),
                   labels = c("ChromHMM\nannotation", "ChIP\nannotation")) +
  labs(title = "Alluvial Flow: chromHMM → ChIP",
       y = "Count of Segments",
       x = NULL) +
  theme_minimal()

```
##### Priority ver 2
```{r}
# 
# ### Complex annotation
# collapsed3 <- collapsed2 %>%
#   dplyr::mutate(annotation = if_else(flag_insulator, "S",
#                                      if_else(flag_promoter, "P",
#                                              if_else(flag_enhancer, "E",
#                                                      if_else(flag_transcription, "T", 
#                                                              if_else(flag_repressive, "R",
#                                                                      if_else(flag_heterochromatin, "H", "X")))))))
# 
# temp <- collapsed3 %>% dplyr::mutate(name = "anchors") %>%
#   dplyr::select(name, annotation)
# temp <- temp %>%
#   mutate(
#     annotation = fct_relevel(annotation, (c("P", "E", "S", "T", "R", "X")))
#   )
# num = nrow(temp)
# p7 = ggplot(temp, aes(x = name, fill = annotation)) +
#   geom_bar(color = "black") +
#   theme_bw() +
#   labs(title = paste0(num, " anchors"),
#        x = "", y = "Counts") +
#   scale_y_continuous(labels = comma_format()) +
#   theme(plot.title = element_text(hjust = 0.5),
#         aspect.ratio = 5,
#         legend.position = "right",
#         legend.direction  = "vertical")

### Simple annotation
collapsed3 <- collapsed2 %>%
  dplyr::mutate(annotation = if_else(flag_insulator, "S",
                                     if_else(flag_promoter, "P",
                                             if_else(flag_enhancer, "E", "X"))))

temp <- collapsed3 %>% dplyr::mutate(name = "anchors") %>%
  dplyr::select(name, annotation)
temp <- temp %>%
  mutate(
    annotation = fct_relevel(annotation, (c("P", "E", "S", "X")))
  )
num = nrow(temp)
p7 = ggplot(temp, aes(x = name, fill = annotation)) +
  geom_bar(color = "black") +
  theme_bw() +
  labs(title = paste0(num, " anchors"),
       x = "", y = "Counts") +
  scale_y_continuous(labels = comma_format()) +
  theme(plot.title = element_text(hjust = 0.5),
        aspect.ratio = 5,
        legend.position = "right",
        legend.direction  = "vertical")

anchor.tb$annot_chromHmm <- collapsed3$annotation
anchor.tb <- anchor.tb %>% dplyr::mutate(anchor_id = paste(chr, start, end, sep = "_"))

# Merging with ChIP annotation
name <- "chromo_cons_allRes_postprocessed_annoHierarchy"
consensus.loop.anno.tb <- fread(here(loopDir, paste0(name, ".tsv")))

consensus.loop.anno.tb <- consensus.loop.anno.tb %>%
  dplyr::mutate(anchor_id_1 = paste(chrom1, start1, end1, sep = "_"),
                anchor_id_2 = paste(chrom2, start2, end2, sep = "_"))


consensus.loop.anno.tb <- consensus.loop.anno.tb %>%
  left_join(
    anchor.tb %>% select(anchor_id, annot_chromHmm),
    by = c("anchor_id_1" = "anchor_id")
  ) %>%
  rename(A1_chromHmm = annot_chromHmm) %>%
  left_join(
    anchor.tb %>% select(anchor_id, annot_chromHmm),
    by = c("anchor_id_2" = "anchor_id")
  ) %>%
  rename(A2_chromHmm = annot_chromHmm)

consensus.loop.anno.tb <- consensus.loop.anno.tb %>% dplyr::rowwise() %>%
  dplyr::mutate(Anno_chromHmm = paste0(A1_chromHmm, "-", A2_chromHmm),
                Anno2_chromHmm = if_else(Anno_chromHmm == "E-P", "P-E", 
                                         if_else(Anno_chromHmm == "S-P", "P-S",
                                                 if_else(Anno_chromHmm == "X-P", "P-X",
                                                         if_else(Anno_chromHmm == "S-E", "E-S",
                                                                 if_else(Anno_chromHmm == "X-E", "E-X",
                                                                         if_else(Anno_chromHmm == "X-S", "S-X",
                                                                                 Anno_chromHmm)))))),
  ) %>% ungroup()

consensus.loop.anno.tb$Anno2_chromHmm = factor(consensus.loop.anno.tb$Anno2_chromHmm, level = c("X-X",
                                                            "S-X", "S-S",
                                                            "E-X","E-S","E-E",
                                                            "P-E","P-X", "P-S", "P-P"))


fwrite(consensus.loop.anno.tb, here(loopDir, paste0(name, "_chromHmm.tsv")), 
       sep = "\t", col.names = TRUE)
temp <- consensus.loop.anno.tb %>% dplyr::select(-Anno2) %>% rename(Anno2 = Anno2_chromHmm)
createLoopAnnotation(temp, paste0(name, "_chromHMM"), figDir, colorListLoop)


counts <- consensus.loop.anno.tb %>%
  group_by(Anno2, Anno2_chromHmm) %>%
  summarise(Freq = n(), .groups = "drop")

counts$Anno2 <- factor(counts$Anno2, levels = c("X-X",
                                                "S-X", "S-S",
                                                "E-X","E-S","E-E",
                                                "P-E","P-X", "P-S", "P-P"))
counts$Anno2_chromHmm <- factor(counts$Anno2_chromHmm, levels = c("X-X",
                                                                  "S-X", "S-S",
                                                                  "E-X","E-S","E-E",
                                                                  "P-E","P-X", "P-S", "P-P"))

# 2. Draw the alluvial plot
ggplot(counts,
       aes(axis1 = Anno2, axis2 = Anno2_chromHmm, y = Freq)) +
  # flows
  geom_alluvium(aes(fill = Anno2), width = 0.25) +
  # strata (the blocks at each axis)
  geom_stratum(width = 0.25, fill = "grey80", color = "black") +
  # stratum labels
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3) +
  # axis labels
  scale_x_discrete(limits = c("Anno2", "Anno2_chromHmm"),
                   labels = c("Anno2", "Anno2_chromHmm")) +
  labs(title = "Alluvial Flow: ChIP → chromHMM",
       y = "Count of Segments",
       x = NULL) +
  theme_minimal()




# 
# annotation.tb <- annotateAnchorTSSAnchor(anchor.tb)  %>% dplyr::rowwise() %>%
#     dplyr::mutate(
#       annot_chip = if_else((A1_H3K4me3TSS), "P", 
#                    if_else((A1_H3K27ac), "E",
#                            if_else((A1_CTCF|A1_RAD21), "S", "X")))
#     ) %>%
#   dplyr::select(annot_chromHmm, annot_chip) %>% ungroup()
#   
# 
# temp <- annotation.tb %>% dplyr::mutate(name = "anchors") %>%
#   dplyr::select(name, annot_chip)
# temp <- temp %>%
#   mutate(
#     annot_chip = fct_relevel(annot_chip, (c("P", "E", "S", "X")))
#   )
# num = nrow(temp)
# p7 = ggplot(temp, aes(x = name, fill = annot_chip)) +
#   geom_bar(color = "black") +
#   theme_bw() +
#   labs(title = paste0(num, " anchors"),
#        x = "", y = "Counts") +
#   scale_y_continuous(labels = comma_format()) +
#   theme(plot.title = element_text(hjust = 0.5),
#         aspect.ratio = 5,
#         legend.position = "right",
#         legend.direction  = "vertical")
# 
# library(ggalluvial)
# 
# counts <- annotation.tb %>%
#   group_by(annot_chromHmm, annot_chip) %>%
#   summarise(Freq = n(), .groups = "drop")
# 
# counts$annot_chromHmm <- factor(counts$annot_chromHmm, levels = c("P", "E", "S", "X"))
# counts$annot_chip <- factor(counts$annot_chip, levels = c("P", "E", "S", "X"))
# 
# # 2. Draw the alluvial plot
# ggplot(counts,
#        aes(axis1 = annot_chromHmm, axis2 = annot_chip, y = Freq)) +
#   # flows
#   geom_alluvium(aes(fill = annot_chromHmm), width = 0.25) +
#   # strata (the blocks at each axis)
#   geom_stratum(width = 0.25, fill = "grey80", color = "black") +
#   # stratum labels
#   geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3) +
#   # axis labels
#   scale_x_discrete(limits = c("annot_chromHmm", "annot_chip"),
#                    labels = c("ChromHMM\nannotation", "ChIP\nannotation")) +
#   labs(title = "Alluvial Flow: chromHMM → ChIP",
#        y = "Count of Segments",
#        x = NULL) +
#   theme_minimal()

```

