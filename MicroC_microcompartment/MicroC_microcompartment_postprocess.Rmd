---
title: "R Notebook"
---
# LOADING REQUIREMENTS
## PACKAGES
```{r message=FALSE, warning=FALSE, include=FALSE}
# LIST OF PACKAGES
pkgs = c("tidyverse", "here", "svglite", "ggplot2", "ggrepel",
         "stringr", "BiocManager", "RColorBrewer", "viridis", "magick",
         "nlme", "factoextra", "devtools", "beepr", "remotes",
         "cowplot", "data.table", "strawr", "rtracklayer", "utils",
         "reshape2", "VennDiagram","gridExtra", "eulerr", "scales",
         "InteractionSet", "gplots", "locfdr", "future", "ggbeeswarm", "glossary", "ggalluvial", "UpSetR")
bio_pkgs = c("biomaRt", "DESeq2", "ComplexHeatmap", "apeglm", "vsn",
             "rhdf5", "InteractionSet", "plotgardener", "HiCDCPlus",
             "GenomicInteractions", "LOLA", "AnnotationHub",
             "org.Mm.eg.db", "enrichplot", "DOSE", "clusterProfiler",
             "HiCExperiment", "HiCool", "HiContacts", "HiContactsData", "fourDNData", "DNAZooData",
             "MotifDb", "Biostrings")

# INSTALL PACKAGES
# install.packages(pkgs)
# BiocManager::install(bio_pkgs)

# INSTALL HiC related packages
# remotes::install_github("robinweide/GENOVA")
# devtools::install_github("thomasp85/scico")
# devtools::install_github("psyteachr/introdataviz")

# LOAD PACKAGES
lapply(pkgs, require, character.only = TRUE)
lapply(bio_pkgs, require, character.only = TRUE)
require(GENOVA)
require(scico)
require(introdataviz)
require(igraph)
# CLEANING
rm(pkgs, bio_pkgs)

options(scipen=999)



```
## ENSEMBL
```{r}
# ENSEMBL DATABASE
# v102 is for the latest mm10 version
# ensembl.v102 <- useMart(host = "https://nov2020.archive.ensembl.org",
#                        biomart = "ENSEMBL_MART_ENSEMBL",
#                        dataset = "mmusculus_gene_ensembl")
```
## COLOR PALETTE
```{r}
palette_1 = list(red = "#E9002D",
                 amber = "#FFAA00",
                 green = "#00B000")
palette_2 = list(red = "#FF1F5B",
                 green = "#00CD6C",
                 blue = "#009ADE",
                 purple = "#AF58BA",
                 yellow = "#FFC61E",
                 orange = "#F28522",
                 grey = "#A0B1BA",
                 brown = "#A6761D")
palette_3 = list(grey1 = "#a0b1ba",
                 grey2 = "#c5d0d5",
                 grey3 = "#eceff1")

colorListLoop <-  c(palette_3[["grey3"]], palette_3[["grey2"]], palette_3[["grey1"]],
                     "#C5E1EF", "#6CB0D6", "#226E9C",
                     "#06592A", 
                     "#FED976", "#FD8D3C", "#E31A1C")
colorListPromoter <- c(palette_3[["grey3"]],"#E88587", "#E31A1C")
colorListEnhancer <- c(palette_3[["grey3"]],"#87AFC7", "#226E9C")
colorListStructure <- c(palette_3[["grey3"]], palette_3[["grey2"]], palette_3[["grey1"]])
```

## DIR LIST
```{r}
loopDir <- "/Volumes/UKJIN_SSD/data/microcompartment"
figDir <- "/Volumes/UKJIN_SSD/figure/microcompartment"

dir.create(figDir, showWarnings = FALSE)
```

## FIGURE PARAMETERS
```{r}
library(colorspace)

fontType <- "Helvetica"

fontSizeL <- 10 # pt
fontSizeM <- 8
fontSizeS <- 6

lineThick <- 0.75 # pt
lineMedium <- 0.5
lineThin <- 0.25

panelUnit <- 30 # mm
panelMargin <- 1.5

mmToInch <- 0.03937007874
mmToLineUnit <- 1/2.13
mmToLinePlotgarden <- 1/0.75
ptToMM <- 1/2.845


strong_red <- "#CB333A"
strong_blue <- "#4851A0"
weak_red <- lighten(strong_red, amount = 0.4)   # FF7D81
weak_blue <- lighten(strong_blue, amount = 0.4) # 8A91DD
no_grey <- "#A8A8A8"

strong_teel <- "#0892A5"
strong_green <- "#23CE6B" # A485
strong_darkgreen <- "#054A29"
strong_yellow <- "#FFBA49"
strong_orange <- "#F18F01" # dTAG
strong_lightpurple <- "#BD93D8"
strong_purple <- "#9E33CB" # Epi

panelSize <- function(num, unit = panelUnit, margin = panelMargin){
  return(num*unit - 2*margin)
}

```

## FUNCTIONS
```{r}
importBedpe = function(bedpe){
  a1 = makeGRangesFromDataFrame(data.frame(
    chr = bedpe$V1,
    start = bedpe$V2 +1,
    end = bedpe$V3))
  a2 = makeGRangesFromDataFrame(data.frame(
    chr = bedpe$V4,
    start = bedpe$V5 +1,
    end = bedpe$V6))
  GInteractions(a1, a2)
}

get_density <- function(x, y, ...) {
  dens <- MASS::kde2d(x, y, ...)
  ix <- findInterval(x, dens$x)
  iy <- findInterval(y, dens$y)
  ii <- cbind(ix, iy)
  return(dens$z[ii])
}
label_kb_mb <- function(x) {
  ifelse(x >= 1000000, paste0(x / 1000000, "Mb"), paste0(x / 1000, "kb"))
}

importPeak = function(fileName){
  df = fread(fileName)
  gr = makeGRangesFromDataFrame(data.frame(
    chr = df$V1, start = df$V2, end = df$V3
  ))
}
```


# [v] Make filtered bedpe
```{r}
# Importing & filtering loops
filterLoopBedpe = function(sample, note, cutoff.score, cutoff.qvalue,
                           inputDir, outputDir){
  temp = as_tibble(fread(here(inputDir, 
                              paste0(sample, "_chromosight_", note, ".tsv"))))
  temp.filtered = temp %>% dplyr::filter(score > cutoff.score, qvalue < cutoff.qvalue)
  fwrite(temp.filtered, here(outputDir, paste0(sample, "_microcompartment_", note, ".bedpe")), 
         col.names = FALSE,row.names = FALSE, sep = "\t")  
}

for(sample in c("G1DMSO_pooled", "G1dTAG_pooled")){

  for(note in c("25000bp")){
    filterLoopBedpe(sample = sample, note = note,
                    cutoff.score = 0.3, cutoff.qvalue = 1e-5,
                    inputDir = loopDir, outputDir = loopDir)
  }
}
```
# Post-processing called loops
Step 2) Post-processing: Synchronizing loops across conditions. 3x3 bin window used to determine whether the loops are same. 
Step 3) Post-processing: Merging over resolutions.
Merge 25kb to lower resolution by checking 25kb 3x3 bin window. If there are 25kb loop that has lower resolution loop within 3x3 window, discard the 25kb called loop. After that, repeat for 10 kb.
## Step 2
```{r}
################################################################################
# Step 2
################################################################################

process_chromosome <- function(data_chr) {
  
  # Get the number of rows for this chromosome
  n <- nrow(data_chr)
  
  # If there's 0 or 1 row, no pairs can be made. Return early.
  if (n <= 1) {
    return(
      data_chr %>%
        mutate(
          group = paste(chrom1, .row_id, sep = "_"), # Each row is its own group
          is_best = TRUE,
          DMSOcalledProcessed = DMSOcalled,
          dTAGcalledProcessed = dTAGcalled
        )
    )
  }
  
  # 1) Build neighbor‐edges: all pairs (i, j) with |bin1[i] - bin1[j]| ≤1 AND |bin2[i] - bin2[j]| ≤1
  coords <- data_chr %>% select(bin1, bin2)
  n <- nrow(data_chr)

  # 2) Create all (i,j) pairs with i < j, then filter
  pairs <- expand.grid(i = 1:n, j = 1:n) %>%
    filter(i < j) %>%
    filter(
      abs(coords$bin1[i] - coords$bin1[j]) <= 1,
      abs(coords$bin2[i] - coords$bin2[j]) <= 1
    )

  # 3) Turn into an undirected graph and extract components
  g <- graph_from_data_frame(pairs, directed = FALSE, vertices = data.frame(name = 1:n))
  comps <- components(g)$membership

  # 4) Annotate your tibble with “group” and “is_best”
  data_chr <- data_chr %>%
    mutate(group = comps[.row_id]) %>%
    group_by(group) %>%
    mutate(
      is_best               = score == max(score),
      DMSOcalledProcessed   = any(DMSOcalled),
      dTAGcalledProcessed   = any(dTAGcalled)
    ) %>%
    ungroup() %>%
    dplyr::select(-.row_id)
  
  return(data_chr)
}

# Merge loops across condition
for (res in c(25000)){
  
  loop1 <- fread(here(loopDir, paste0("G1DMSO_pooled_microcompartment_25000bp.bedpe"))) %>% dplyr::select(seq(1, 6))
  loop2 <- fread(here(loopDir, paste0("G1dTAG_pooled_microcompartment_25000bp.bedpe"))) %>% dplyr::select(seq(1, 6))

  
  loop.merged <- bind_rows(loop1, loop2) %>% distinct()
  fwrite(loop.merged, here(loopDir, paste0("microcompartment_union_", res, "bp.bedpe")), 
         sep = '\t', col.names = FALSE, row.names = FALSE)
}

# Run "chromosight quantify" with union loops in all condition

# Merge loops across conditions for each resolution. 3x3 bin window used to determine whether the loops are same. 
for (res in c(25000)){
  score.DMSO.tb <- fread(here(loopDir, paste0("G1DMSO_pooled_union_", res, "bp_pu100pz100.tsv"))) %>%
    dplyr::mutate(id = paste(chrom1, start1, end1,
                             chrom2, start2, end2, sep="_")) %>%
    dplyr::select(c("chrom1", "start1", "end1", "chrom2", "start2", "end2", "bin1", "bin2",
                    "id", "score", "pvalue", "qvalue")) %>%
    dplyr::rename(score_DMSO = score,
                  pvalue_DMSO = pvalue,
                  qvalue_DMSO = qvalue) 
  score.dTAG.tb <- fread(here(loopDir, paste0("G1dTAG_pooled_union_", res, "bp_pu100pz100.tsv"))) %>%
    dplyr::mutate(id = paste(chrom1, start1, end1,
                             chrom2, start2, end2, sep="_")) %>%
    dplyr::select(c("chrom1", "start1", "end1", "chrom2", "start2", "end2", "bin1", "bin2",
                    "id", "score", "pvalue", "qvalue")) %>%
    dplyr::rename(score_dTAG = score,
                  pvalue_dTAG = pvalue,
                  qvalue_dTAG = qvalue) 
  
  
  # Annotate whether the loop was called in each conditions
  loop.DMSO <- fread(here(loopDir, paste0("G1DMSO_pooled_chromosight_", res, "bp.tsv"))) %>% 
    dplyr::mutate(id = paste(chrom1, start1, end1,
                             chrom2, start2, end2, sep="_"))
  loop.dTAG <- fread(here(loopDir, paste0("G1dTAG_pooled_chromosight_", res, "bp.tsv"))) %>% 
    dplyr::mutate(id = paste(chrom1, start1, end1,
                             chrom2, start2, end2, sep="_"))
  
  
  score.tb <- full_join(score.DMSO.tb, score.dTAG.tb,
                        by = c("chrom1", "start1", "end1",
                               "chrom2", "start2", "end2",
                               "bin1", "bin2", "id")) %>%
    dplyr::mutate(DMSOcalled = id %in% loop.DMSO$id,
                  dTAGcalled = id %in% loop.dTAG$id,
                  ) %>%
    dplyr::mutate(
      score = pmax(score_DMSO, score_dTAG),
      .row_id   = row_number()           # temporary ID for graph nodes
    )
  

  # final_results <- score.tb %>%
  #   group_split(chrom1) %>%          # Split into a list of tibbles, one per chromosome
  #   map(process_chromosome) %>%        # Apply our function to each tibble in the list
  #   list_rbind()
  # 
  # temp <- final_results %>% dplyr::filter(is_best)


  
  
  # 1) Build neighbor‐edges: all pairs (i, j) with |bin1[i] - bin1[j]| ≤1 AND |bin2[i] - bin2[j]| ≤1
  coords <- score.tb %>% select(bin1, bin2)
  n <- nrow(score.tb)
  
  # 2) Create all (i,j) pairs with i < j, then filter
  pairs <- expand.grid(i = 1:n, j = 1:n) %>%
    filter(i < j) %>%
    filter(
      abs(coords$bin1[i] - coords$bin1[j]) <= 1,
      abs(coords$bin2[i] - coords$bin2[j]) <= 1
    )
  
  # 3) Turn into an undirected graph and extract components
  g <- graph_from_data_frame(pairs, directed = FALSE, vertices = data.frame(name = 1:n))
  comps <- components(g)$membership
  
  # 4) Annotate your tibble with “group” and “is_best”
  score.tb <- score.tb %>%
    mutate(group = comps[.row_id]) %>%
    group_by(group) %>%
    mutate(
      is_best               = score == max(score),
      DMSOcalledProcessed   = any(DMSOcalled),
      dTAGcalledProcessed   = any(dTAGcalled)
    ) %>%
    ungroup() %>%
    dplyr::select(-.row_id)
  
  temp <- score.tb %>% dplyr::filter(is_best)
  
  ##############################################################################
  raw_sets <- list(
    DMSO    = which(score.tb$DMSOcalled),
    dTAG    = which(score.tb$dTAGcalled)
  )
  
  svglite(here(figDir, paste0("upset_raw_", res, ".svg")), width = 6, height = 4)
  print(upset(
    fromList(raw_sets),
    nsets = 5,
    order.by = "freq",
    mb.ratio = c(0.6, 0.4),
    point.size = 3,
    line.size = 1,
    main.bar.color = "steelblue",
    matrix.color = "firebrick"
  ))
  dev.off()
  
  
  # 2) PROCESSED calls
  proc_sets <- list(
    DMSO    = which(temp$DMSOcalledProcessed),
    dTAG    = which(temp$dTAGcalledProcessed)
  )
  
  svglite(here(figDir, paste0("upset_processed_", res, ".svg")), width = 6, height = 4)
  print(upset(
    fromList(proc_sets),
    nsets = 5,
    order.by = "freq",
    mb.ratio = c(0.6, 0.4),
    point.size = 3,
    line.size = 1,
    main.bar.color = "steelblue",
    matrix.color = "firebrick"
  ))
  dev.off()
  
  
  
  # Export bedpe
  fwrite(temp %>% dplyr::select(c(1, 2, 3, 4, 5, 6)), here(loopDir, paste0("microcompartment_union_", res, "bp_postprocessed.bedpe")), sep = "\t", col.names = FALSE)
  
  
  fwrite(temp %>% dplyr::select(-seq(16, 22)), here(loopDir, paste0("microcompartment_union_", res, "bp_postprocessed.tsv")), sep = "\t")
}


```

## Filtering bsed on distance
```{r}
res <- 25000
data <- fread(here(loopDir, paste0("microcompartment_union_", res, "bp_postprocessed.tsv"))) %>%
  dplyr::mutate(size = start2 - start1)

temp <- data %>% dplyr::filter(size > 2*1000000) %>%
  dplyr::filter(size <= 10*1000000) %>% dplyr::select(seq(1, 6))
fwrite(temp, here(loopDir, paste0("microcompartment_union_", res, "bp_postprocessed_2Mb_10Mb.bedpe")), sep = "\t", col.names = FALSE)

temp <- data %>% dplyr::filter(size > 10*1000000) %>%
  dplyr::filter(size <= 20*1000000) %>% dplyr::select(seq(1, 6))
fwrite(temp, here(loopDir, paste0("microcompartment_union_", res, "bp_postprocessed_10Mb_20Mb.bedpe")), sep = "\t", col.names = FALSE)

temp <- data %>% dplyr::filter(size > 20*1000000) %>%
  dplyr::filter(size <= 30*1000000) %>% dplyr::select(seq(1, 6))
fwrite(temp, here(loopDir, paste0("microcompartment_union_", res, "bp_postprocessed_20Mb_30Mb.bedpe")), sep = "\t", col.names = FALSE)

temp <- data %>% dplyr::filter(size > 30*1000000) %>%
  dplyr::filter(size <= 40*1000000) %>% dplyr::select(seq(1, 6))
fwrite(temp, here(loopDir, paste0("microcompartment_union_", res, "bp_postprocessed_30Mb_40Mb.bedpe")), sep = "\t", col.names = FALSE)

temp <- data %>% dplyr::filter(size > 40*1000000) %>%
  dplyr::filter(size <= 50*1000000) %>% dplyr::select(seq(1, 6))
fwrite(temp, here(loopDir, paste0("microcompartment_union_", res, "bp_postprocessed_40Mb_50Mb.bedpe")), sep = "\t", col.names = FALSE)

# ggplot(data, aes(x = score_DMSO, y = score_dTAG)) + geom_point() + xlim(-0.5, 1) + ylim(-0.5, 1) + coord_fixed()
# 
# ggplot(data %>% dplyr::filter(size > 2*1000000) %>%
#   dplyr::filter(size <= 10*1000000), aes(x = score_DMSO, y = score_dTAG)) + geom_point() + xlim(-0.5, 1) + ylim(-0.5, 1) + coord_fixed()
# 
# ggplot(data %>% dplyr::filter(size > 10*1000000) %>%
#   dplyr::filter(size <= 20*1000000), aes(x = score_DMSO, y = score_dTAG)) + geom_point() + xlim(-0.5, 1) + ylim(-0.5, 1) + coord_fixed()
# 
# ggplot(data %>% dplyr::filter(size > 20*1000000) %>%
#   dplyr::filter(size <= 30*1000000), aes(x = score_DMSO, y = score_dTAG)) + geom_point() + xlim(-0.5, 1) + ylim(-0.5, 1) + coord_fixed()
# 
# ggplot(data %>% dplyr::filter(size > 30*1000000) %>%
#   dplyr::filter(size <= 40*1000000), aes(x = score_DMSO, y = score_dTAG)) + geom_point() + xlim(-0.5, 1) + ylim(-0.5, 1) + coord_fixed()
# 
# ggplot(data %>% dplyr::filter(size > 40*1000000) %>%
#          dplyr::filter(size <= 50*1000000), aes(x = score_DMSO, y = score_dTAG)) + geom_point() + xlim(-0.5, 1) + ylim(-0.5, 1) + coord_fixed()
# 

data <- data %>% dplyr::mutate(group = case_when(
  between(size, 2e6, 10e6) ~ "2Mb<size<=10Mb",
  between(size, 10e6, 20e6) ~ "10Mb<size<=20Mb",
  between(size, 20e6, 30e6) ~ "20Mb<size<=30Mb",
  between(size, 30e6, 40e6) ~ "30Mb<size<=40Mb",
  between(size, 40e6, 50e6) ~ "40Mb<size<=50Mb",
  
))

data$group <- factor(data$group, levels = c("2Mb<size<=10Mb",
                                            "10Mb<size<=20Mb",
                                            "20Mb<size<=30Mb",
                                            "30Mb<size<=40Mb",
                                            "40Mb<size<=50Mb"))
##########################
dataToPlot <- data %>% dplyr::select(group, score_DMSO, score_dTAG) %>% 
  pivot_longer(-group, names_to = "condition", values_to = "score")

summary_labels <- dataToPlot %>%
  group_by(group, condition) %>%
  summarise(
    n = n(),
    # Set position for the label slightly above the max value in each group
    y_position = 0.7
  ) %>%
  ungroup()

p <- ggplot(dataToPlot, aes(x = condition, y = score, fill = condition)) + 
  geom_violin(linewidth   = lineThick * mmToLineUnit,
              lineend     = "square",
              alpha       = .4,
              show.legend = FALSE) +
  geom_boxplot(width       = 0.3,
               color       = "black",
               linewidth   = lineThick * mmToLineUnit,
               lineend     = "square",
               outlier.shape = NA,
               alpha       = 0.6,
               show.legend = FALSE) + 
  facet_grid(~group) + 
  geom_text(
    data = summary_labels, 
    aes(y = y_position, label = paste("n =", n)),
    fontface = "bold",
    size = 1
  ) + 
  ylim(-0.1, 0.8) +
  geom_hline(yintercept = 0,
             size       = lineThick * mmToLineUnit,
             lineend    = "square",
            linetype = "dashed") +
  theme_classic() +
  theme(
    legend.position = "none",
    plot.title = element_text(
      hjust = 0.5,
      size = fontSizeS,
      family = fontType
    ),
    axis.title = element_text(
      size = fontSizeS,
      family = fontType,
      color = "#000000"
    ),
    axis.text = element_text(
      size = fontSizeS,
      family = fontType,
      color = "#000000"
    ),
    axis.line = element_line(
      color = "#000000",
      size = lineThick*mmToLineUnit,
      lineend = "square"
    ),
    axis.ticks = element_line(
      color = "#000000",
      size = lineThick*mmToLineUnit,
      lineend = "square"
    ),
    panel.background = element_rect(fill = "transparent"),
  ) + scale_fill_manual(values = c(no_grey, strong_orange))


width <- panelSize(3)*mmToInch
height <- panelSize(1.5)*mmToInch  

fileName <- paste0("Violinplot_score_microcompartment")
svglite(here(figDir, paste0(fileName, ".svg")), 
        width = width, height = height)
print(p)
dev.off()




##############################################################################
temp <- data %>% dplyr::filter(group == "2Mb<size<=10Mb")
t.test(temp$score_dTAG, temp$score_DMSO, paired = TRUE)

temp <- data %>% dplyr::filter(group == "10Mb<size<=20Mb")
t.test(temp$score_dTAG, temp$score_DMSO, paired = TRUE)

temp <- data %>% dplyr::filter(group == "20Mb<size<=30Mb")
t.test(temp$score_dTAG, temp$score_DMSO, paired = TRUE)

temp <- data %>% dplyr::filter(group == "30Mb<size<=40Mb")
t.test(temp$score_dTAG, temp$score_DMSO, paired = TRUE)

temp <- data %>% dplyr::filter(group == "40Mb<size<=50Mb")
t.test(temp$score_dTAG, temp$score_DMSO, paired = TRUE)


```

# Visualization of heatmap
```{r}
# Drawing parameters
hicDir <- here("../data/hic_pooled")
windowSize <- 1*1e6

# Importing loops
dataDir <- here("../data/microcompartment")
microcompartments <- importBedpe(as_tibble(fread(here(dataDir, "microcompartment_union_25000bp_postprocessed.bedpe"))))

################################################################################
## Loading hic and plotting
cf.G1DMSO <- HicFile(path = here(hicDir, "G1DMSO_pooled_allRes.hic"))
cf.G1dTAG <- HicFile(path = here(hicDir, "G1dTAG_pooled_allRes.hic"))

width <- panelSize(20)*mmToInch
height <- panelSize(10)*mmToInch

chr <- "chr1"
start <- 62e6
end <- 112e6


for(resolution in c(25)){
  res <- resolution*1000
  zmax <- 2.5
  
  hic1 <- import(cf.G1DMSO, focus = paste0(chr, ":", start, "-", end), resolution = res)
  hic2 <- import(cf.G1dTAG, focus = paste0(chr, ":", start, "-", end), resolution = res)
  p1 <- plotMatrix(hic1, use.scores = "balanced", limits = c(-1, 2.5), dpi = 1000, loop = microcompartments)
  p2 <- plotMatrix(hic2, use.scores = "balanced", limits = c(-1, 2.5), dpi = 1000, loop = microcompartments, )
  
  fileName <- here(figDir, sprintf("visuzliation_microcompartment_balanced_%dkb", resolution))
  svglite(paste0(fileName, ".svg"), width = width, height = height)
  print(cowplot::plot_grid(p1, p2, nrow = 1, align = "h"))
  dev.off()
}
```

